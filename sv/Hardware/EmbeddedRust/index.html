

	






<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Rust för inbyggda system - En introduktion - UTBULT DESIGN</title>
		
		<!-- Skeleton responsive boilerplate and base stylesheets -->
		<link rel="stylesheet" href="../../../static/css/skeleton.css">
		<link rel="stylesheet" href="../../../static/css/normalize.css">

		<!-- Theme specific stylesheets -->
		<link rel="stylesheet" href="../../../static/fonts/fonts.css">
		<link rel="stylesheet" href="../../../static/css/base.css">
		<link rel="stylesheet" href="../../../static/css/slider.css">
		<link rel="stylesheet" href="../../../static/css/header.css">
		<link rel="stylesheet" href="../../../static/css/burgerMenu.css">

		<style>
			.btn {
				color: #ff0000;
			}
		</style>

		<!-- highlight.js stylesheets -->
		<link rel="stylesheet" href="../../../static/css/highlightjs.css">
		
		
		<!-- Light -->
		<!-- <link rel="stylesheet" href="../../../static/highlight/styles/docco.min.css"> -->
		<!-- <link rel="stylesheet" href="../../../static/highlight/styles/panda-syntax-light.min.css"> -->
		
		<!-- Page specific stylesheets -->
		
		

		<!-- Base script handling burger menu, dark and light mode -->
		<script src="../../../static/js/base.js"></script>

		
		<!-- Extra javascript from config file -->
		
		<script src="../../../javascript/mathjax.js"></script>
		
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		
		<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
		
		

		<!-- highlight.js script -->
		<script src="../../../static/highlight/highlight.min.js"></script>
		<script>
			hljs.configure({ignoreUnescapedHTML: true}); 
			hljs.highlightAll();
		</script>

		<!-- Page specific scripts -->
		
		

		<!-- MKDocs specific scripts -->

	</head>
	<body>
		<div id="header" onclick="closeBurgerMenu()">
			<a class="logo" href="../../..
	
		/sv/
	
">
				<img src="../../../static/svg/Utbult-Design-Logo/logo/UtbultDesign_White.svg">
				<img src="../../../static/svg/Utbult-Design-Logo/logo/UtbultDesign_Black.svg">
			</a>
			<div>
				<div class="btn-container">
					<a href="
	
		../../../en/Hardware/EmbeddedRust/
	
">
						<button class="btn">
							In English
						</button>
					</a>
				</div>
				<label class="switch"> 
					<!-- <input id="theme-switch" type="checkbox" onclick="toggleLightDarkMode()"> -->
					<input id="theme-switch" type="checkbox" onclick="toggleLightDarkMode()" checked>
					<span class="slider">
						<!-- Moon icon -->
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
							<!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
							<path
								d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z" />
						</svg>

						<!-- Sun icon -->
						<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
							<!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
							<path
								d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z" />
						</svg>
					</span>
				</label>
			</div>
		</div>
		<div id="burger-menu">
			<div id="burger-menu-button-container">
				<button onclick="toggleBurgerMenu()">
					<img src="../../../static/svg/icons/burger-solid.svg"/>
				</button>
			</div>
			<div id="burger-menu-content">
				<div>
					<ul id="nav">
						
							

<li >
  <div class="burger-heading-container">
    <a href="../../">
      <h1>UTBULT DESIGN</h1>
    </a>
    <div></div>
  </div>  
</li>


						
							

<li >
  <div class="burger-heading-container">
    <a href="../../about_me/">
      <h1>Om mig</h1>
    </a>
    <div></div>
  </div>  
</li>


						
							

  <li>
    <div class="burger-heading-container">
      
        
          <a href="../">
        
      
        
      
            <h1>Hardware</h1>
      
        
          </a>
        
      
        
      
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
      
      
      
      

<li class="active">
  <div class="burger-heading-container">
    <a href="./">
      <h1>Rust för inbyggda system - En introduktion</h1>
    </a>
    <div></div>
  </div>  
</li>


      
    </ul>
  </li>


						
							

  <li>
    <div class="burger-heading-container">
      
        
          <a href="../../Music/">
        
      
        
      
        
      
        
      
        
      
            <h1>Music</h1>
      
        
          </a>
        
      
        
      
        
      
        
      
        
      
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
      
      
      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Music/RustSoundcard/">
      <h1>Ljudkort i Rust</h1>
    </a>
    <div></div>
  </div>  
</li>


      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Music/TheDONG/">
      <h1>The DONG</h1>
    </a>
    <div></div>
  </div>  
</li>


      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Music/test/">
      <h1>test</h1>
    </a>
    <div></div>
  </div>  
</li>


      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Music/test2/">
      <h1>test2</h1>
    </a>
    <div></div>
  </div>  
</li>


      
    </ul>
  </li>


						
							

  <li>
    <div class="burger-heading-container">
      
        
          <a href="../../Software/">
        
      
        
      
        
      
            <h1>Software</h1>
      
        
          </a>
        
      
        
      
        
      
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
      
      
      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Software/HomebreweryCoCTheme/">
      <h1>Homebrewery Call of Cthulhu Tema</h1>
    </a>
    <div></div>
  </div>  
</li>


      
      

<li >
  <div class="burger-heading-container">
    <a href="../../Software/UtbultDesignSite/">
      <h1>Utbult Design site</h1>
    </a>
    <div></div>
  </div>  
</li>


      
    </ul>
  </li>


						
					</ul>
					
					
					
						
					
					
					<hr>

					
					<h1>Rust för inbyggda system - En introduktion</h1>
					
					<ul id="toc">
						<li>
						
							
<li >
  <div class="burger-heading-container">
    <a href="#vad-ar-rust">
      <h2>Vad är Rust?</h2>
    </a>
    <div></div>
  </div>  
</li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#rustup">
            <h2>Rustup</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#rustup-installation-manjaro">
      <h3>Rustup installation - Manjaro</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#introduktion-till-rust">
            <h2>Introduktion till rust</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
  <li>
    <div class="burger-heading-container">
        <a href="#exempel-1-hello-world">
            <h3>Exempel 1 - Hello World</h3>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#kompilera-programmet">
      <h4>Kompilera programmet</h4>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-2-printa-med-argument">
      <h3>Exempel 2 - Printa med argument</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-3-variabler">
      <h3>Exempel 3 - Variabler</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-4-andra-variabler">
      <h3>Exempel 4 - Ändra variabler</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-5-strangar">
      <h3>Exempel 5 - Strängar</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-6-if-satser-loopar-och-sant">
      <h3>Exempel 6 - If-satser, loopar och sånt</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-7-funktioner">
      <h3>Exempel 7 - Funktioner</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-8-agandeskap">
      <h3>Exempel 8 - Ägandeskap</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#exempel-9-lanande">
      <h3>Exempel 9 - Lånande</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#cargo">
            <h2>Cargo</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#rustup-vs-cargo">
      <h3>Rustup vs Cargo</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#skapa-ett-projekt">
            <h2>Skapa ett projekt</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#debug-eller-release">
      <h3>Debug eller Release</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
<li >
  <div class="burger-heading-container">
    <a href="#cargotoml-och-cargolock">
      <h2>Cargo.toml och Cargo.lock</h2>
    </a>
    <div></div>
  </div>  
</li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#vs-code-introduktion">
            <h2>VS Code - Introduktion</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#vs-code-installation-manjaro">
      <h3>VS Code installation - Manjaro</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#rust-plugin">
      <h3>Rust plugin</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#workspaces">
      <h3>Workspaces</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#kompilera-och-debugga-i-vs-code">
      <h3>Kompilera och debugga i VS Code</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#embedded-rust">
            <h2>Embedded rust</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#embedded-kod">
      <h3>Embedded kod</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
  <li>
    <div class="burger-heading-container">
        <a href="#flasha-din-kod">
            <h3>Flasha din kod</h3>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#nrf-tools-installation-manjaro-med-yay">
      <h4>NRF tools installation - Manjaro med yay</h4>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#nrf-tools-installation-manjaro-med-aur">
      <h4>NRF tools installation - Manjaro med AUR</h4>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

    
    </ul>
  </li>

						
							
  <li>
    <div class="burger-heading-container">
        <a href="#debugging-i-embedded-rust">
            <h2>Debugging i embedded rust</h2>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
  <li>
    <div class="burger-heading-container">
        <a href="#gdb">
            <h3>GDB</h3>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#gdb-installation-manjaro-med-pacman">
      <h4>GDB installation - Manjaro med Pacman</h4>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#konfigurera-gdb">
      <h4>Konfigurera GDB</h4>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

    
        
  <li>
    <div class="burger-heading-container">
        <a href="#openocd">
            <h3>OpenOCD</h3>
        </a>
      <div>
        <button onclick="toggleBurgerMenuInstance(this)">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor" preserveAspectRatio="none">
              <!--! Font Awesome Pro 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->
              <path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul class="hidden">
    
        
<li >
  <div class="burger-heading-container">
    <a href="#openocd-installation-manjaro-med-pacman">
      <h4>OpenOCD installation - Manjaro med Pacman</h4>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#konfigurera-openocd">
      <h4>Konfigurera OpenOCD</h4>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#rust-runners">
      <h3>Rust runners</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#forsta-testet">
      <h3>Första testet</h3>
    </a>
    <div></div>
  </div>  
</li>

    
        
<li >
  <div class="burger-heading-container">
    <a href="#anvandning-av-gdb">
      <h3>Användning av GDB</h3>
    </a>
    <div></div>
  </div>  
</li>

    
    </ul>
  </li>

						
							
<li >
  <div class="burger-heading-container">
    <a href="#embedded-rust-i-vscode">
      <h2>Embedded Rust i VSCode</h2>
    </a>
    <div></div>
  </div>  
</li>

						
						</li>
					</ul>
					
				</div>
			</div>
		</div>
		<div class="content-container" onclick="closeBurgerMenu()">
			<div id="content" class="container">
				<div class="header-margin"></div>
				
<h1 id="rust-for-inbyggda-system-en-introduktion">Rust för inbyggda system - En introduktion</h1>
<h2 id="vad-ar-rust">Vad är Rust?</h2>
<blockquote>
<p>Rust is a modern systems programming language developed by the Mozilla Corporation. It is intended to be a language for highly concurrent and highly secure systems. It compiles to native code; hence, it is blazingly fast like C and C++.</p>
</blockquote>
<p><a href="https://www.tutorialspoint.com/rust/index.htm">Tutorialspoint on Rust</a></p>
<p>Vad är då fördelen med Rust?</p>
<blockquote>
<p>Systems and application programming languages face two major problems
It is difficult to write secure code
(and) it is difficult to write multi-threaded code.</p>
</blockquote>
<p>Iden med Rust är att ha ett programmeringsspråk som prioriterar att utveckla snabba, hårdvarunära program. Detta görs med <em>concurrency</em>, dvs att programmet består av olika delar som kan köras samtidigt.</p>
<h2 id="rustup">Rustup</h2>
<p><a href="https://www.tutorialspoint.com/rust/rust_environment_setup.htm">Tutorialspoint</a></p>
<p><em>Rustup</em> är ett terminalbaserat verktyg för att hantera versioner av rustkompilatorn och de verktyg som krävs för att kompilera rustkod.</p>
<p>När rustup installeras kommer också en kompilator för rust att hänga med, kallad <em>rustc</em>.</p>
<h3 id="rustup-installation-manjaro">Rustup installation - Manjaro</h3>
<pre><code class="language-bash">sudo pacman -S rustup
</code></pre>
<h2 id="introduktion-till-rust">Introduktion till rust</h2>
<p>Här kommer en introduktion till rust. Om du känner att du har koll kan du skippa den. Annars om du känner dig relativt säker men vill ha en genomgång om ägandeskap kan du kolla <a href="#exempel-8-agandeskap">Exempel 8 - Ägandeskap</a> och <a href="#exempel-9-lanande">Exempel 9 - Lånande</a>.</p>
<h3 id="exempel-1-hello-world">Exempel 1 - Hello World</h3>
<p>Vi börjar med ett enkelt exempel. Vi ska skriva ett <em>hello world</em> program i rust och kompilerar det för att köras på din dator.</p>
<p>Börja med att skapa en mapp som heter <code>exempel1-helloWorld</code></p>
<pre><code class="language-bash">mkdir exempel1-helloWorld
cd exempel1-helloWorld
</code></pre>
<p>Där i vill vi skapa sourcefilen för hello world programmet</p>
<pre><code class="language-bash">touch helloWorld.rs
</code></pre>
<p>Notera att filändelsen för rust är <code>.rs</code></p>
<p>Senare går vi igenom hur man använder en IDE för att skriva, kompilera och köra rustkod i. Men för enkelhetens skull börjar vi med att använda en textredigerare för att skriva koden i och en terminal för att kompilera och köra i.</p>
<p>Öppna denna fil i en textredigerare. Jag rekommenderar <a href="https://www.sublimetext.com/">Sublime Text</a> för enkelhetens skull. Där lägger du till.</p>
<pre><code class="language-rust">fn main()  
{
    println!(&quot;Hello world!&quot;);  
}
</code></pre>
<p>Här har vi några nyckelord.</p>
<p><code>fn</code> är en definition för att skapa en funktion, och
<code>fn main()</code> är då den funktionen som kommer att köras när ett kompilerat rustprogram startar.</p>
<p><code>println!</code> är ett <em>macro</em> för att printa text. Ett macro är egentligen ett namn för en bit kod som är definierad på något annat ställe. Vi som programmerare behöver inte veta exakt hur ett program ska bära sig åt för att printa text på en terminal, utan vi vill bara kunna göra det. Därför använder vi ett macro för att printa text, som sedan ersätts med den bit kod som är nödvändig just för att printa under kompileringsprocessen.</p>
<p>Det viktiga du behöver veta är att ett macro alltid markeras i rust med ett utropstecken, därför är det <code>println!</code> och inte <code>println</code>.</p>
<h4 id="kompilera-programmet">Kompilera programmet</h4>
<p>För att kompilera programmet använder vi en kompilator som hänger med i [[#Rustup|rustup]], kallad <em>rustc</em>. I <code>exempel1-helloWorld</code> där sourcefilen <code>helloWorld.rs</code> ligger vill du vara. Där kallar du på <code>rustc</code> och skickar in sourcefilen som ska kompileras.</p>
<pre><code class="language-bash">rustc helloWorld.rs
</code></pre>
<p>Detta kommer genera en fil med samma namn, fast utan filändelsen <code>.rs</code>. Detta är vårt program.</p>
<p>Testa att köra programmet i terminalen</p>
<pre><code class="language-bash">./helloWorld
</code></pre>
<p>Skriver den ut <em>Hello world!</em>? Isåfall funkade allt, och din kod kompilerades.</p>
<h3 id="exempel-2-printa-med-argument">Exempel 2 - Printa med argument</h3>
<p>När man testar saker i vilket programmeringsspråk som helst, kan det vara bra att kunna printa vad en variabel innehåller. I rust kan vi, istället för att själv göra en sträng och sätta i variabeln i den, printa med <em>argument</em>.</p>
<p>Det betyder egentligen att vi skriver i en sträng <em>vart ett argument ska skrivas ut</em>. Detta görs i rust med <code>{}</code>.</p>
<p>Vi gör ett exempelprogram där vi sparar antalet bröder du har i en variabel, och sedan printar denna variabel.</p>
<p>Gör en ny mapp med namnet <code>example2-printaMedArgument</code> och i den, skapa en sourcefil med namnet <code>howManyBrothers.rs</code>.</p>
<pre><code class="language-bash">mkdir example2-howManyBrothers
cd example2-howManyBrothers
touch howManyBrothers.rs
</code></pre>
<p>I denna nya fil kan du skriva följande</p>
<pre><code class="language-rust">fn main()
{
    println!(&quot;I have {} brothers.&quot;, 3);
}
</code></pre>
<p>Sedan kompilera och kör programmet på samma sätt som i <a href="exempel-1-hello-world">exempel 1</a></p>
<pre><code class="language-bash">rustc howManyBrothers.rs
./howManyBrothers
</code></pre>
<p>Det som händer nu är att rust ser att du har ett argument, <code>3</code> i mitt fall, och att du har <code>{}</code> i strängen som ska printas. Rust tar därför argumentet och sätter in det där det står <code>{}</code>, vilket resulterar i <code>I have 3 brothers.</code></p>
<h3 id="exempel-3-variabler">Exempel 3 - Variabler</h3>
<p>Rust kan, på samma sätt som till exempel python, själv räkna ut vilken typ en variabel ska vara utifrån den data du skickar in i denna.</p>
<p>För att deklarera en variabel i rust använder du <code>let</code>.</p>
<p>Vi gör om det föregående exemplet, fast nu använder vi en variabel för att spara hur många bröder du har.</p>
<pre><code class="language-bash">mkdir example3-howManyBrothersVar
cd example3-howManyBrothersVar
touch howManyBrothersVar.rs
</code></pre>
<p>Nu vill vi istället specificera en variabel där vi sparar hur många bröder du har och sedan använder den här variabeln i printsatsen.</p>
<pre><code class="language-rust">fn main() {
    let brothers = 3;  
    println!(&quot;I have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Testa att kompilera och köra detta</p>
<pre><code class="language-bash">rustc howManyBrothersVar.rs
./howManyBrothersVar
</code></pre>
<p>Vi kan dock säga explicit till rust att en variabel ska vara en specifik typ. Om vi till exempel vet att vi behöver inte ha ett negativt antal bröder, och vi kommer aldrig ha mer än 255 bröder. Isåfall kan vi spara antalet bröder i en unsigned (positiv) 8-bitars heltal; en <code>u8</code>.</p>
<p>I rust specificerar vi detta igenom att skriva ett kolon efter variabelnamnet och sedan vilken typ den ska vara (innan lika med tecknet).</p>
<p>Testa att lägga till detta</p>
<pre><code class="language-rust">fn main() {  
    let brothers:u8 = 3;  
    println!(&quot;I have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Kompilerar du och kör detta, kommer du få samma resultat som förut. Skulle du nu dock välja att ha ett negativt antal bröder, kommer rust inte att låta dig kompilera då vi explicit sagt att denna variabel ska vara ett <strong>positivt</strong> 8-bitars tal.</p>
<p>Testa att byta antalet bröder till <code>-1</code> och kompilera.</p>
<pre><code class="language-rust">fn main() {  
    let brothers:u8 = -1;  
    println!(&quot;I have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Detta resulterar i följande error</p>
<pre><code class="language-bash"> |     let brothers:u8 = -1;  
 |                       ^^  
 |                       |  
 |                       cannot apply unary operator `-`
</code></pre>
<p>Alltså, operatorn <code>-</code> funkar inte på ett positivt heltal. Vill du läsa mer om olika typer rekommenderar jag <a href="https://www.tutorialspoint.com/rust/rust_data_types.htm">Tutorialspoint: Rust - Data Types</a>.</p>
<h3 id="exempel-4-andra-variabler">Exempel 4 - Ändra variabler</h3>
<p>I de flesta programmeringsspråk har du variabler som man kan ändra värde på, och variabler som du specificerat ska vara konstanta (dvs att dessa inte ska ändras efter att de skapats). </p>
<p>Detta är dock inte fallet i rust. Här måste du istället specificera att en variabel <strong>ska</strong> gå att ändra på.</p>
<p>Vi testar med ett nytt exempel</p>
<pre><code class="language-bash">mkdir example4-howManyBrothersUpdate
cd example4-howManyBrothersUpdate
touch howManyBrothersUpdate.rs
</code></pre>
<p>Säg att du har ett program där du sparar hur många bröder du har och sedan printar ut detta antal. Men precis mellan det ögonblick programmet sparar antalet bröder och ska printa ut det, får du en ny bror (något av ett edge case men ändå). Du vill därför ändra antalet bröder du har efter att du skapat variabeln.</p>
<pre><code class="language-rust">fn main()  
{ 
    let brothers = 3;
    println!(&quot;I have {} brothers.&quot;, brothers);

    brothers = 4;  
    println!(&quot;I now have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Försöker du kompilera detta får du följande error</p>
<pre><code class="language-bash"> |     brothers = 4;  
 |     ^^^^^^^^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>Det den säger är i princip att du försöker skriva över en <em>immutable</em> (konstant) variabel.</p>
<p>Det man behöver göra i rust för att en variabel ska få ändras, är att specificera att den ska vara <em>mutable</em> (muterbar/möjlig att ändra). Detta gör du med nyckelordet <code>mut</code>.</p>
<p>Testa att lägga till <code>mut</code> framför deklarationen av variabeln (mellan <code>let</code> och variabelnamnet)</p>
<pre><code class="language-rust">fn main()  
{ 
    let mut brothers = 3;
    println!(&quot;I have {} brothers.&quot;, brothers);

    brothers = 4;  
    println!(&quot;I now have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Nu lyckas programmet kompileras och köras.</p>
<p>Variabler kan även deklareras som <em>konstanta</em> i rust, vilket ger dem en del mer restriktioner. Är du mer intresserad av det kan du läsa <a href="https://www.tutorialspoint.com/rust/rust_constant.htm">Tutorialspoint: Rust - Constants</a>.</p>
<h3 id="exempel-5-strangar">Exempel 5 - Strängar</h3>
<p>Rust gör en distinkt skillnad mellan två sorters strängar; litterala strängar och strängobjekt.</p>
<p>En <em>litteral sträng</em> är en sträng som definieras under kompileringen och sedan används av programmet, men den ändras aldrig. Exempelvis om du har en meny i ditt program, där alla alternativ skrivs ut i en terminal. Programmet kommer aldrig att själv ändra sin meny, och därför kan denna sträng vara statisk.</p>
<p>Notera att detta inte betyder att du inte kan spara strängen i en variabel. Det kan du göra med följande typ.</p>
<pre><code class="language-rust">fn main() {
    let name:&amp;str = &quot;Josef&quot;;
}
</code></pre>
<p>Ett strängobjekt är en sträng som programmet själv kommer att ändra på. För att få en sån behöver du skapa strängobjektet med funktionen <code>new()</code>.</p>
<pre><code class="language-rust">fn main() {
    let mut buffer = String::new();
}
</code></pre>
<p>För att ändra strängen sedan finns en massa funktioner (kolla in <a href="https://www.tutorialspoint.com/rust/rust_string.htm">Tutorialspoint: Rust - String</a>). I exempel kan vi använda funktionen <code>push_str()</code>, för att fylla på strängobjektet med en litteral sträng (alltså en vi vet vad den innehåller under kompileringen)</p>
<pre><code class="language-rust">fn main() {
    let mut buffer = String::new();
    buffer.push_str(&quot;Hello&quot;);
}
</code></pre>
<h3 id="exempel-6-if-satser-loopar-och-sant">Exempel 6 - If-satser, loopar och sånt</h3>
<p>Vi går snabbt igenom lite om if-satser, loopar och liknande.</p>
<p>I rust behöver du inte ha parenteser runt if, for och while satser (på samma sätt som i python)</p>
<pre><code class="language-rust">// En if-sats utan paranteser
if i == 2 {
    // Do stuff
}
</code></pre>
<p>For loopar i rust ser också lite annorlunda ut. Du behöver inte deklarera en variabel som du sedan använder för att loopa över. Rust kan lista ut det själv.</p>
<p>För att loopa från ett värde till ett annat använder du det som heter <code>in</code> och definierar en range som ska loopas över. Här loopar vi från 0 till, men inte med, 10</p>
<pre><code class="language-rust">for j in 0..10 {
    // Do stuff
}
</code></pre>
<p>Vill du läsa på mer, kan du se över <a href="https://www.tutorialspoint.com/rust/rust_loop.htm">Tutorialspoint: Rust - Loop</a></p>
<h3 id="exempel-7-funktioner">Exempel 7 - Funktioner</h3>
<p>Funktioner i rust deklareras med nyckelordet <code>fn</code>. Man kan specificera vad funktionen retunerar med <code>-&gt; type</code>.</p>
<pre><code class="language-rust">fn function_name(var1, var2) -&gt; return_type {
   // Stuff
   return value;
}
</code></pre>
<p>Man kan också retunera ett värde i en funktion igenom att avsluta en funktion <strong>utan</strong> semikolon på slutet</p>
<pre><code class="language-rust">fn function_name(var1, var2) -&gt; return_type {
   // The same thing as return value;
   value
}
</code></pre>
<p>Variabler för indata till funktionen kan man också specificera vilka typer det ska vara, på samma sätt som när man deklarerar en variabel</p>
<pre><code class="language-rust">fn function_name(var1:u8, var2:&amp;str) {
   // Stuff
}
</code></pre>
<p>Förutom explicita värden kan referenser till variabler skickas in i funktioner (som pekare i C)</p>
<pre><code class="language-rust">fn main()
{
    let mut no:i32 = 5;
    mutate_no_to_zero(&amp;mut no);
    println!(&quot;The value of no is:{}&quot;,no);
}
fn mutate_no_to_zero(param_no:&amp;mut i32)
{
    *param_no = 0; //de reference
}
</code></pre>
<h3 id="exempel-8-agandeskap">Exempel 8 - Ägandeskap</h3>
<p>En del som är mer omständligt i rust jämfört med till exempel C eller python, är att <strong>en variabel kan endast ägas av en funktion</strong>.</p>
<p>Här måste vi dock göra en distinkt skillnad mellan variabler som är av en <em>primitiv typ</em> eller en som inte är det.</p>
<p>En variabel av en primitiv typ är en enkel variabel som är inbyggd i rust (typ). Detta inkluderar till exempel <code>u8</code>, <code>i8</code>, <code>f8</code>, <code>bool</code> och <code>char</code>.</p>
<p>Men när en variabel är mer komplicerad, någonting som kanske kan vara olika storlekar eller en typ som du som användare skapad (en klass till exempel), är detta inte en primitiv typ.</p>
<p>I C++ kan du till exempel ha en funktion som tar in en referens till en variabel. Här använder vi en vektor då det inte är en primitiv typ. Funktionen kan ändra på datan i vektorn, som då också ändras för datan där funktionen kallades</p>
<pre><code class="language-cpp">// Funktion som tar in en referens för en vektor
void bar(vector&lt;int&gt;&amp; vect)
{
    // Referera till variabeln ändra något i den
    vec.push_back(3);
}
void foo()
{
    // Skapa en vektor och sätt två av värdena i den
    vector&lt;int&gt; vect;
    vect.push_back(1);
    vect.push_back(2);

    // Kalla på bar med vektorn
    bar(vec);

    // Vi kan nu fortfarande använda vektorn, 
    // men storleken har ändrats efter att bar 
    // har kallats
    cout &lt;&lt; vec.size() &lt;&lt; endl;
}
</code></pre>
<p>I rust däremot gäller följande
- En variabel får bara <em>ägas</em> av en funktion i taget
- Två variabler får inte peka på samma minnesadress</p>
<p>Det här påverkar mest icke-primitiva typer. Lite senare går vi igenom hur det funkar för primitiva typer.</p>
<p>Det betyder i princip att samma kod i rust inte hade fungerat. Det är för att efter att funktionen <code>bar</code> kallas på med variabeln som indata, <em>konsumeras</em> denna variabel av funktionen och kan inte längre användas.</p>
<pre><code class="language-rust">// Funktion som tar in en vektor och ändrar på den  
fn bar(mut vec:Vec&lt;u8&gt;)  
{  
    vec.push(3);
}  

fn main()  
{  
    // Skapa en vektor  
    let mut vec:Vec&lt;u8&gt; = Vec::new();  
    vec.push(1);  
    vec.push(2);  
    // Kalla på bar med vektorn som indata  
    bar(vec);  
    // Detta fungerar inte, då vec har konsumerats  
    // av funktionen bar  
    println!(&quot;Size: {}&quot;, vec.len());  
}
</code></pre>
<p>Försöker vi kompilera det här får vi ett error som säger att variabeln vec har flyttats (och inte kunnat kopieras) och inte längre ägs av mainfunktionen. Därför kan den inte användas längre</p>
<pre><code class="language-bash"> |     let mut vec:Vec&lt;u8&gt; = Vec::new();  
 |         ------- move occurs because `vec` has type `Vec&lt;u8&gt;`, which does not implement the `Copy` trait  
...  
 |     bar(vec);  
 |         --- value moved here  
...  
 |     println!(&quot;Size: {}&quot;, vec.len());  
 |                          ^^^^^^^^^ value borrowed here after move
</code></pre>
<p>Det betyder också att om vi försöker att skapa en variabel och kopierar den, får vi inte längre använda den gamla variabeln</p>
<pre><code class="language-rust">fn main()  
{  
    // Skapa en vektor  
    let mut vec:Vec&lt;u8&gt; = Vec::new();  
    vec.push(1);  
    vec.push(2);  

    // Det här är okej. Ägandeskapet till vec ligger 
    // nu i vec2  
    let vec2 = vec;  

    // Det här går dock inte, då vec inte längre 
    // finns utan har konsumerats  
    println!(&quot;Size: {}&quot;, vec.len());  
}
</code></pre>
<p>Anledningen till detta handlar om hur värden sparas när programmet körs. Det finns beskrivet bra i <a href="https://www.tutorialspoint.com/rust/rust_ownership.htm">Tutorialspoint: Rust - Ownership</a>.</p>
<p>Undantaget till detta är dock om man använder primitiva typer. Det är för att rust vet hur dessa ska kopieras på ett bra sätt. Hade föregående exempel istället varit för variabler av typen <code>u8</code>, räknar rust ut att det den ska göra är att <em>kopiera innehållet i variabeln</em>.</p>
<pre><code class="language-rust">fn main()
{
    // Skapa en primitiv variabel
    let u1 = 1;
    // Sätt värdet på en annan variabel till den
    // första variabeln. Detta resulterar i att
    // värdet i den första variabeln sätts på
    // den andra
    let u2 = u1;
    // Därför fungerar detta, då u2 inte är samma 
    // variabel som u1, utan bara har samma värde
    println!(&quot;u1: {}&quot;, u1);
}
</code></pre>
<h3 id="exempel-9-lanande">Exempel 9 - Lånande</h3>
<p>Man skulle kunna komma runt föregående exempel igenom att efter att funktionen körts, retunera variabeln och spara den i en ny variabel. </p>
<pre><code class="language-rust">// Funktion som tar in en vektor, ändrar på den och  
// sedan retunerar den  
fn bar(mut vec:Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;    
{     
    vec.push(3);  
    return vec;  
}     
    
fn main()     
{     
    // Skapa en vektor     
    let mut vec:Vec&lt;u8&gt; = Vec::new();     
    vec.push(1);     
    vec.push(2);     
    // Kalla på bar med vektorn som indata, och skapa  
    // en ny variabel med vektorn som funktionen  
    // retunerar    
    let vec2 = bar(vec);     
    // Detta fungerar då vec2 typ är en ny vektor    
    println!(&quot;Size: {}&quot;, vec2.len());     
}
</code></pre>
<p>Det blir dock lätt omständligt. Därför kan en funktion även <em>låna</em> en variabel. Den får en lånad variabel som indata, där den kan ändra på saker. Men när funktionen körts klart lämnas variabeln tillbaks.</p>
<p>Detta görs i rust igenom att <em>referera</em> till variabeln med ett <code>&amp;</code></p>
<pre><code class="language-rust">// Funktion som lånar en vektor. Notera &amp; innan variabeltypen  
fn bar(vec:&amp;Vec&lt;u8&gt;)  
{     
    println!(&quot;Size from a function: {}&quot;, vec.len());  
}     
    
fn main()     
{     
    // Skapa en vektor     
    let mut vec:Vec&lt;u8&gt; = Vec::new();     
    vec.push(1);     
    vec.push(2);     
    // Skicka in en referens till vec, vilket låter bar låna den  
    bar(&amp;vec);     
    // Vi har fortfarande kvar vec och kan använda den  
    println!(&quot;Size: {}&quot;, vec.len());     
}
</code></pre>
<p>Notera dock att vi inte kan ändra på variabeln i det här fallet, utan endast använda den. För att variabeln ska kunna ändras måste vi specificera att den ska vara muterbar <strong>både i funktionsdeklarationen och i funktionskallet</strong>. Detta görs med nyckelordet <code>&amp;mut</code></p>
<pre><code class="language-rust">// Funktion som lånar en vektor och har rätt att ändra på den.    
// Notera &amp;mut innan variabeltypen  
fn bar(vec:&amp;mut Vec&lt;u8&gt;)  
{
    // Ändrar inehållet i vec. Utdatan sparas i en 
    // skräpvariabel, då rust annars genererar en 
    // varning angående utdata från lånade variabler
    let _ = &amp;vec.push(3);     
    println!(&quot;Size from a function: {}&quot;, vec.len());  
}     
    
fn main()     
{     
    // Skapa en vektor     
    let mut vec:Vec&lt;u8&gt; = Vec::new();     
    vec.push(1);     
    vec.push(2);     
    // Skicka in en referens till vec, vilket låter bar låna den  
    // och ändra på den. Notera att vi explicit specificerar att  
    // variabeln ska vara en muterbar referens  
    bar(&amp;mut vec);     
    // Vi har fortfarande kvar vec och kan använda den. Nu har den  
    // dock ändrats av funktionen  
    println!(&quot;Size: {}&quot;, vec.len());     
}
</code></pre>
<h2 id="cargo">Cargo</h2>
<p>I rust har vi det som kallas <em>crates</em>, vilket är som bibliotek i C. Det som dock är smidigt mer rust är att installationen och versionshantering av crates sköts av pakethanterare: <em>Cargo</em>.</p>
<p>Cargo är ganska likt pip om du använt det. Skillnaden är att cargo också löser virtuella miljöer (typ) och byggandet av projekt själv. Cargo hänger också med i rustup, vilket är smidigt.</p>
<h3 id="rustup-vs-cargo">Rustup vs Cargo</h3>
<p>Här ser du vad som är skillnaden mellan rustup och cargo</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/RustupAndCargo.svg" /></p>
<p>Här är en till guide som också går igenom hur man kommer igång med rust <a href="https://medium.com/codex/rust-a-beginner-cheat-sheet-8fd7b0ce49de">Meduim: Rust - A Beginner Cheat Sheet</a></p>
<p>För mer information om crates kan du kolla in <a href="https://www.tutorialspoint.com/rust/rust_modules.htm">Tutorialspoint: Rust - Modules</a></p>
<h2 id="skapa-ett-projekt">Skapa ett projekt</h2>
<p>När du vill skapa ett projekt i rust använder du cargo. Du kan testa igenom att köra följande, som kommer att skapa mappen <code>cargo_test</code></p>
<pre><code class="language-bash">cargo new cargo_test
</code></pre>
<p>Det cargo gör är att den sätter upp en mappstruktur för dig och skapar de filer som krävs för att börja. Så här ser mappen ut när du skapar den</p>
<pre><code>├── Cargo.toml  
└── src  
   └── main.rs
</code></pre>
<p>Du får en <code>src</code> mapp där all din kod ska ligga och i den ligger <code>main.rs</code>, vilket är den fil programmet kommer leta efter funktionen main i. </p>
<p>I <code>main.rs</code> finns redan ett hello world exempel, så vi ska testa att bygga det. Det fina med att ha skapat projektet på det här sättet med cargo är att vi kan använda cargo för att bygga projektet. Om du är i mappen <code>cargo_test</code> kan du bara köra <code>cargo build</code> för att kompilera programmet och <code>cargo run</code> för att köra det.</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<p>Cargo bygger då programmet och kör det, vilket printar ut <code>Hello, world!</code> på terminalen.</p>
<p>Efter att du byggt programmet ser ditt projekt ut något såhär</p>
<pre><code>├── Cargo.lock  
├── Cargo.toml  
├── src  
│   └── main.rs  
└── target  
   ├── CACHEDIR.TAG  
   └── debug  
       ├── build  
       ├── cargo_test  
       ├── cargo_test.d  
       ├── deps  
       │   ├── cargo_test-99e382143f4d3aca  
       │   └── cargo_test-99e382143f4d3aca.d  
       ├── examples  
       └── incremental
</code></pre>
<p>Det som är väsentligt här är filen <code>target/debug/cargo_test</code>. Det är ditt program! Du kan faktiskt köra den manuellt om du vill testa</p>
<pre><code class="language-bash">./target/debug/cargo_test
</code></pre>
<h3 id="debug-eller-release">Debug eller Release</h3>
<p>Rust kan bygga ditt program på lite olika sätt. Som standard är att programmet byggs i <em>debug</em>, vilket betyder att kompilatorn lägger till en del saker för att göra felsökning lite enklare. Det är därför ditt program hamnar i mappen <code>debug</code>.</p>
<p>Om du en dag vill bygga en version av ditt program som ska användas kan du välja att bygga det i <em>release</em> läget. Rust kommer då att optimera och göra programmet mindre.</p>
<pre><code class="language-bash">cargo build --release
cargo run --release
</code></pre>
<h2 id="cargotoml-och-cargolock">Cargo.toml och Cargo.lock</h2>
<p>När du skapar ett nytt projekt genereras en fil som heter <code>Cargo.toml</code>. Sedan när du kompilerar projektet genereras en till fil som heter <code>Cargo.lock</code>.</p>
<p>Dessa filer beskriver vilka versioner av saker som projektet använder. <code>Cargo.toml</code> är den fil som du som programmerare skriver i. Där kan du specificera vad ditt program heter, vilken version den är på och vilka övriga crates ditt program behöver använda för att kunna köra.</p>
<p><code>Cargo.lock</code> skapas sedan automatiskt när du bygger ditt projekt. Den specificerar exakt vilka versioner av olika crates som användes när du kompilerade ditt program. Den låser alltså versionerna. Detta gör att om en annan programmerare sedan bygger ditt projekt, kommer han få de exakta versionerna av de crates som du använde, vilket betyder att ditt program beter sig likadant för honom.</p>
<p>Du kan testa att lägga till en modul i din <code>Cargo.toml</code> fil. Under <code>[dependencies]</code> kan du lägga följande</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex.git&quot; }
</code></pre>
<p>Kör du nu <code>cargo build</code> kommer den börja att ladda ner regex craten från github, och sedan bygga ditt projekt. Kollar du nu i <code>Cargo.lock</code> kommer du se att den har lagt till en massa saker som har med regex att göra. Det fina är att du aldrig behöver ändra i den filen själv, bara se till att pusha den om du laddar upp ditt projekt med git.</p>
<h2 id="vs-code-introduktion">VS Code - Introduktion</h2>
<p><a href="https://www.geeksforgeeks.org/how-to-setup-rust-in-vscode/">Geeks for Geeks - How to Setup Rust in VSCode?</a></p>
<p>VS Code är en IDE skapad av Microsoft. Den är dock nu open-source. VS Code har bra support för att lägga till moduler, vilket låter en enkelt använda den för olika programmeringsspråk.</p>
<h3 id="vs-code-installation-manjaro">VS Code installation - Manjaro</h3>
<pre><code class="language-bash">sudo pacman -S vscode
</code></pre>
<p>För att sedan köra VS Code kör du programmet som heter <code>code</code>.</p>
<h3 id="rust-plugin">Rust plugin</h3>
<p>I VS Code kan du installera pluginet <code>rust-analyzer</code>. Den kommer att analysera din kod, ge dig code completion och hitta varningar och errors.</p>
<p>Gå till <code>Extentions</code> i vänsterpanelen i VS Code.</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeExtentions.png" /></p>
<p>Väl där kan du söka upp <code>rust-analyzer</code> och installera den</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeRustAnalyzer.png" /></p>
<p>För att debugga kod kan du också installera <code>CodeLLDB</code></p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeCodeLLDB.png" /></p>
<h3 id="workspaces">Workspaces</h3>
<p>I VS Code har du det som kallas <em>workspaces</em>. Det kan beskrivas som den mapp där din kod ligger. Testa att öppna testprojektet igenom att gå till <code>File &gt; Open Folder...</code> och välja <code>cargo_test</code> mappen.</p>
<p>Nu ska mappen dyka upp på vänstersidan, med alla submappar och filer. Testa att öppna <code>src/main.rs</code>. Där har du din hello world kod, och allt är färgat korrekt vilket innebär att VS Code fattar att det ska vara rust kod.</p>
<p>Testa att skriva in ett av de icke-fungerande exemplen som finns under [[#Introduktion till rust]] och spara <code>main.rs</code>.</p>
<pre><code class="language-rust">fn main() {  
   let brothers:u8 = -1;  
   println!(&quot;I have {} brothers.&quot;, brothers);  
}
</code></pre>
<p>Nu kommer du få ett rött sträck under <code>-1</code>. Om du hovrar musen över sträcket får du en hjälpruta som beskriver varför din kod är fel.</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeError.png" /></p>
<h3 id="kompilera-och-debugga-i-vs-code">Kompilera och debugga i VS Code</h3>
<p>VS Code har en integrerad terminal i sig, vilken man kan använda för att manuellt bygga och köra ditt program. Går till <code>Terminal &gt; New Terminal</code> för att få upp den. Det kommer öppna en terminal som befinner sig i workspace mappen. Testa att bygga och köra din kod i den.</p>
<pre><code class="language-bash">cargo build
cargo run
</code></pre>
<p>Det är helt okej, men det smidiga med VS Code är att du manuellt kan specificera vad VS Code ska göra när du trycker på "Run and Debug".</p>
<p>Gå till menyn "Run and Debug"</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeRun.png" /></p>
<p>Där kan du välja alternativet <code>create a launch.json file</code></p>
<p>![](img/EmbeddedRust/Rust 2022-12-15 20.47.29.excalidraw}</p>
<p>Det kommer ge dig ett fönster där det står att du har en <code>Cargo.toml</code> fil i ditt projekt, och det frågar om du vill generera en fil från den. Välj <code>Yes</code>.</p>
<p>Den kommer generera en fil kallad <code>.vscode/launch.json</code>. Det är en fil som specificerar hur VS Code ska agera när du väljer att bygga ditt projekt.</p>
<p>Det autogenererade ska funka för vårt exempel. Testa att bygga och köra projektet igenom att trycka på knappen <code>RUN AND DEBUG</code></p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeRunAndDebuggButton.png" /></p>
<p>Den kommer att bygga och köra ditt program. Du kan se hur saker händer nere i terminalen. Väljer du fliken <code>Terminal</code> bör du också se att programmet printade "Hello, world!"</p>
<p>Nu kan du testa att debugga ditt program. Om du klickar bredvid din kod, till vänster om ett radnummer i din mainfunktion. Då får du upp en liten röd cirkel.</p>
<p><img alt="" src="../../../Hardware/img/EmbeddedRust/VSCodeDebugSign.png" /></p>
<p>Om du nu kör <code>RUN AND DEBUG</code> kommer ditt program att starta, men det pausar ditt program och sätter det i debuggläge.</p>
<p>Du kan läsa på mer om hur debugging funkar på <a href="https://code.visualstudio.com/Docs/editor/debugging">VS Codes sida</a>.</p>
<h2 id="embedded-rust">Embedded rust</h2>
<p>Här är ett par bra tutorials på det här: <a href="https://jonathanklimt.de/electronics/programming/embedded-rust/rust-on-stm32-2/">Jonathan Klimt - Rust on STM32: Getting started</a> och <a href="https://nitschinger.at/Getting-Started-with-the-nRF52840-in-Rust/">Daschl writes. sometimes - Getting Started with the nRF52840 in Rust</a></p>
<p>Istället för att köra vårt program på en laptop kommer du antagligen vilja köra den på ett devboard, vilket kallas <em>embedded</em>.</p>
<p>Det finns ett par problem med detta. Processorn i din dator är inte densamma som processorn på ditt devboard. Den läser inte samma maskinkod som din dator, utan är byggd med en annan <em>arkitektur</em>.</p>
<p>Processorn som sitter i din dator är antagligen byggd på den arkitekturen som heter <em>x86</em>, medans processorn på din devboard är byggt på arkitekturen <em>ARM</em>.</p>
<p>Sedan måste du också lyckats få programmet till minnet på din devboard. Det är inte som ett usbminne, du kan inte bara flytta över ett program till den, utan du måste skriva till dens minne.</p>
<p>För att komma över det första problemet behöver din kod <em>korskompileras</em> (cross-compile). Det betyder att du har en kompilator på din dator som bygger ett program till en annan arkitektur. Det blir alltså ett program som inte kommer kunna köras på din dator, men det kommer kunna köras på ditt devboard.</p>
<p>I rust kan du ganska enkelt installera en korskompilator med <em>rustup</em>. Det du gör är att installera ett annat <em>toolchain</em>.</p>
<p>Börja med att skapa ett nytt projekt som vi nu kallar <code>embedded_test</code>. Förslagsvis kan du göra det i samma mapp som <code>cargo_test</code> ligger</p>
<pre><code class="language-bash">cargo new embedded_test
cd embedded_test
</code></pre>
<p>Sedan vill vi installera toolchainen som krävs för ARM processorn</p>
<pre><code class="language-bash">rustup target install thumbv7m-none-eabi
</code></pre>
<p>För att sedan skriva till devboardens minne gör du det som heter att <em>flasha</em> minnet. Du kan installera en cargo modul just för att göra detta.</p>
<pre><code class="language-bash">cargo install cargo-flash
</code></pre>
<p>Nu behöver du specificera att det här projektet ska kompileras för en annan arkitektur. Detta gör du igenom att skapa en configfil. I mappen <code>embedded_test</code> kan du köra</p>
<pre><code class="language-bash">mkdir .cargo
cd .cargo
touch config.toml
</code></pre>
<p>Sedan kan du redigera din configfil. Mappen <code>.cargo</code> är en dold mapp, så det kan vara så att du måste specificera att du vill se dolda filer i din filhanterare för att 
kunna gå in i den. I filen <code>config</code> kan du lägga till</p>
<pre><code class="language-toml"># Byggargument
[build]
# Då att vårt target, alltså devboardet, är en ARM 
# processor vill vi att projektet ska korskompileras 
# till ARM
target = &quot;thumbv7em-none-eabi&quot;

# Lite specifikationer för vilken runner som ska användas när vi kör cargo run
[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
runner = &quot;probe-run --chip nRF52840_xxAA&quot;
rustflags = [
    # Adress specifikationer
    &quot;-C&quot;, &quot;link-arg=--nmagic&quot;,
    # Linker
    &quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;,
]
</code></pre>
<p>Efter det behöver vi ett <em>linker skript</em>. Det skriptet specificerar hur minnet på din devboard ska se ut. I mappen <code>embedded_test</code> kan du skapa filen <code>memory.x</code> och lägga till</p>
<pre><code>MEMORY
{
    /* Flashminnet startar på address 0x00000000 och är storleken 64kB*/
    FLASH : ORIGIN = 0x00000000, LENGTH = 1M
    /* Ramminnet startar på address 0x20000000 och är storleken 20kB*/
    RAM : ORIGIN = 0x20000000, LENGTH = 256K
}
</code></pre>
<p>Nu behöver du ändra i filen <code>Cargo.toml</code> för att specificera hur programmet ska byggas. Öppna den och lägg till efter <code>[dependencies]</code></p>
<pre><code class="language-toml">[package]
name = &quot;embedded_test&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

# Containers som krävs för att bygga projektet
[dependencies]
# Tillgång till generiska ARMgrejer, samt att explicit kunna köra assemblyinstruktioner
cortex-m = { version = &quot;^0.7.6&quot;, features = [&quot;inline-asm&quot;] }

# Mer ARM grejer som specificerar hur programmet ska startas
cortex-m-rt = &quot;0.6.12&quot;

# Tillåt printing i embedded kod
rtt-target = { version = &quot;0.3.0&quot;, features = [&quot;cortex-m&quot;] }

# HAL interface som fungerar som mellan lager för din kod och NRF52840 processorn, så du 
# inte behöver lista ut vilka register som gör vad
nrf52840-hal = { version = &quot;0.16.0&quot;, features = [&quot;rt&quot;] }

# Panic handling för när din kod kraschar
panic-rtt-target = { version = &quot;0.1.2&quot;, features = [&quot;cortex-m&quot;] } 

# Specifikationer om hur programmet ska kompileras för release mode
[profile.release]
# Maximera optimering för storlek, då vi inte längre har så mycket minne
opt-level = 'z'

# Link-time-optimizations som kommer hjälpa mer med optimering
lto = true
</code></pre>
<h3 id="embedded-kod">Embedded kod</h3>
<p>Nu ska vi skriva lite kod. I din mainfil <code>src/main.rs</code> kan du skriva följande hello world program</p>
<pre><code class="language-rust">// Main fungerar inte riktigt på samma sätt i embedded    
// rust, så vi måste specificera att den inte ska    
// använda orginella main  
#![no_main]  
// Vi har heller inte standardbiblioteket för att printa  
#![no_std]  

// Vi importerar funktionaliteten från vår HAL  
use nrf52840_hal as _;  
// Vi importerar också ett macro för att kunna printa  
use rtt_target::{rtt_init_print, rprintln};  


#[cortex_m_rt::entry]  
fn main() -&gt; ! {  
    // Initialisera printing  
    rtt_init_print!();  
    // Notera att vi använder macrot rprintln och inte println  
    rprintln!(&quot;Hello, World!&quot;);  
    exit();  
}  

// Här specificerar vi vad som ska hända när programmet kraschar    
#[panic_handler]  
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {  
    rprintln!(&quot;Panic!&quot;);  
    exit();  
}  

// Här har vi en exitfunktion. Den behövs för att processorn inte ska fortsätta köra  
// icke-existerande instruktioner efter vårt program  
pub fn exit() -&gt; ! {  
    loop {  
        cortex_m::asm::bkpt();  
    }  
}
</code></pre>
<p>Notera att vi har lite extra grejer från det <a href="exempel-1-hello-world">hello world exemplet</a> vi gjorde för dator.</p>
<p>Vi börjar med att stänga av några funktioner i rust. <code>#![no_main]</code> specificerar att ditt program <strong>inte</strong> ska starta från main, utan ska starta på ett annat embeddedställe. Sedan refererar vi till funktionen main som en startpunkt från vilken embeddedgrejerna ska starta din kod.</p>
<p>Vi har heller inte tillgång till <em>standardbiblioteket</em>, vilket låter dig till exempel printa saker. Därför lägger vi även till <code>#![no_std]</code>.</p>
<p>Sedan importera lite extra funktionalitet. <code>nrf52840_hal</code> är ett mellanlager mellan din kod och hårdvaran, vilket är en NRF52840 processor. Med den slipper du hålla reda på register och sånt.</p>
<p><code>rtt_target::rprintln</code> implementerar ett nytt macro för att printa: <code>rprintln</code>. Den funkar precis som <code>println</code>, men kan köras på en embeddedenhet.</p>
<p>Sedan specificerar vi en <em>entry point</em>, vilket är där din kod kommer att börja. I vårt fall heter funktionen ändå <code>main</code>, men du kan döpa den till vad som helst.</p>
<p>I mainfunktionen använder vi det nya macrot <code>rprintln</code> för att skriva ut text. Sedan kallar vi på funktionen <code>exit</code>.</p>
<p>Efter det har vi en till funktion som heter <code>panic</code>. Den registreras som vad som ska köras om din kod kraschar. I vårt fall printar vi bara ett meddelande och kallar på <code>exit</code>, men det man också skulle kunna göra här är att man stänger ner externa komponenter korrekt eller dumpar massa info i en loggfil.</p>
<p>Efter det har vi en funktion som heter <code>exit</code>. Det är en funktion vi själva kallar på när vi vill avsluta programmet. Anledningen till att vi gör det är för att din embeddedenhet inte kommer avsluta på samma sätt som ett program på din laptop.</p>
<p>Kör du ett program på din dator kommer en ny process att startas, ditt program körs och sen avslutas processen. Datorn fortsätter sedan med allt den håller på med för att köra ditt operativsystem.</p>
<p>Din embeddedenhet däremot, kommer inte bara sluta köra kod efter att ditt program tar slut. Den kommer att fortsätta plocka instruktioner från minnet. Dessa är inte saker du har lagt där, utan kan vara vadsomhelst. Det vill vi inte att den ska göra, för då kan vad som helst hända. Därför har vi funktionen <code>exit</code> som kommer att sätta processorn i en evighetsloop. Vi lägger också till att den ska placera en breakpoint där, för om vi vill debugga.</p>
<p>Du kan nu bygga din kod. Förutsatt att allt är gjort korrekt, kommer du inte få några error.</p>
<pre><code class="language-bash">cargo build
</code></pre>
<h3 id="flasha-din-kod">Flasha din kod</h3>
<p>Nu när du lyckats bygga ditt projekt är det dags att flasha din kod till ditt devboard. För det behöver du containern <code>probe-run</code></p>
<pre><code class="language-bash">cargo install probe-run
</code></pre>
<p>Du kommer också behöva ett verktyg från <em>Nordic Semiconductors</em> för att interagera med devboarden. Det heter <code>nrf5x-command-line-tools</code></p>
<h4 id="nrf-tools-installation-manjaro-med-yay">NRF tools installation - Manjaro med yay</h4>
<pre><code class="language-bash">yay nrf5x-command-line-tools
</code></pre>
<h4 id="nrf-tools-installation-manjaro-med-aur">NRF tools installation - Manjaro med AUR</h4>
<pre><code>git clone https://aur.archlinux.org/nrf5x-command-line-tools.git
cd nrf5x-command-line-tools
makepkg -si
</code></pre>
<p>För att kunna flasha kod till ditt devboard måste det låsas upp. Det är därför vi behöver <em>NRF tools</em>. Kör kommandot</p>
<pre><code class="language-bash">nrfjprog --recover
</code></pre>
<p>Nu när du låst upp ditt devboard och konfigurerat i <code>.cargo/config</code> att det som ska hända när du kör <code>cargo run</code> är att den ska använda <code>probe-run</code> för att flasha koden till ditt devboard, kan du nu köra koden</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Om allt gått som det ska bör det resultera i följande</p>
<pre><code class="language-bash">   Finished dev [unoptimized + debuginfo] target(s) in 0.01s  
    Running `probe-run --chip nRF52840_xxAA target/thumbv7em-none-eabi/debug/embedded_test`  
(HOST) INFO  flashing program (3 pages / 12.00 KiB)  
(HOST) INFO  success!  
────────────────────────────────────────────────────────────────────────────────  
Hello, World!  
────────────────────────────────────────────────────────────────────────────────  
(HOST) INFO  device halted without error
</code></pre>
<p>Ditt devboard kör alltså hello world koden och skickar hello world till din dator, som sedan printar det i din terminal.</p>
<h2 id="debugging-i-embedded-rust">Debugging i embedded rust</h2>
<p>Att kunna printa saker räcker ofta för att testa enkla saker i ett program, men ibland kan det krävas lite mer kontroll över hur en embeddedplattform körs. I de fallen vill man
ha en debugger för att kunna stoppa körningen av kod och kolla på alla variabler. Problemet med det sätt vi satt upp exempelprojektet nu är att <code>probe-run</code> inte har den 
funktionaliteten. I det här exemplet kommer vi därför sätta upp en <code>gdb</code> instans som kör på din dator och komunicerar med embeddedenheten. Följande exempel följer lite vagt 
<a href="https://ferrous-systems.com/blog/graphical-embedded-rust-debugging/">ferrous systems - Graphical Debugging with Embedded Rust</a></p>
<p>Till att börja med kan du skapa ett nytt projekt i samma mapp som <code>embedded_test</code> som heter <code>gdb_test</code>.</p>
<pre><code class="language-bash">cargo new gdb_test
cd gdb_test
</code></pre>
<p>Kopiera över lite filer från <code>embedded_test</code></p>
<pre><code class="language-bash">cp ../embedded_test/Cargo.toml ./Cargo.toml
cp ../embedded_test/src/main.rs src/main.rs
cp ../embedded_test/memory.x memory.x
cp -r ../embedded_test/.cargo ./.cargo
</code></pre>
<p>Redigera <code>Cargo.toml</code> och byt variabeln <code>name</code> från <code>"embedded_test"</code> till <code>"gdb_test"</code>.</p>
<p>Nu kan vi börja med att sätta upp debuggern. Exakt hur allt fungerar är lite komplicerat, men i grunden 
behöver vi tre komponenter.</p>
<ul>
<li>Cargo</li>
<li>GDB</li>
<li>OpenOCD</li>
</ul>
<p><em>Cargo</em> har vi redan använt för att specificera hur vi ska kompilera projektet och vad som ska hända när vi 
kör <code>cargo run</code>.</p>
<h3 id="gdb">GDB</h3>
<p><em>GDB</em> är det som kallas en <em>debugger</em>. Den ansvarar, på samma sätt som probe-run, för att skicka ett program
som cargo har kompilerat till <em>OpenOCD</em> och sedan för att specificera vart programmet ska stanna. GDB låter
oss också titta på vad som händer på enheten från din laptop.</p>
<p>GDB översätter i princip de instruktionerna som körs i ett program till läsbar kod. I vanliga fall kommer
dessa instruktioner vara i maskinspråket <code>X86</code>, vilket är vad din dator kör. Men det kommer inte fungera
för kod som körs på det inbyggda systemet, som är byggt med en <code>ARM</code> arkitektur. På samma sätt 
<a href="#embedded-rust">som vi tidigare</a> behövde en korskompilator, behöver vi nu en GDB version som kan köras på
din dator men läser ARM kod. För detta använder vi GDB versionen <code>arm-none-eabi-gdb</code>.</p>
<h4 id="gdb-installation-manjaro-med-pacman">GDB installation - Manjaro med Pacman</h4>
<pre><code class="language-bash">sudo pacman -S arm-none-eabi-gdb
</code></pre>
<h4 id="konfigurera-gdb">Konfigurera GDB</h4>
<p>Vi kan konfigurera GDB med en konfigfil.</p>
<p>Skapa filen <code>debug.gdb</code> och lägg till</p>
<pre><code># Koppla till GDB servern som kör lokalt på port 3333 (openocd)
target remote :3333

# Flasha enheten med det program som specificerats i argumentet till gdb
load

# Resetta enheten (openocd)
monitor reset halt

# Starta exekvering av programmet
continue
</code></pre>
<h3 id="openocd">OpenOCD</h3>
<p><em>OpenOCD</em> är det som kallas en <em>embedded debug server</em>. Det är som ett mellanlager mellan GDB och enheten som
koden körs på. Man kan säga att den ansvarar för att ta emot program och instruktioner från GDB och sedan 
komunicera dessa till enheten. När vi kör OpenOCD startar den en lokal server på din dator som GDB kan koppla
upp sig till via port 3333.</p>
<h4 id="openocd-installation-manjaro-med-pacman">OpenOCD installation - Manjaro med Pacman</h4>
<pre><code class="language-bash">sudo pacman -S openocd
</code></pre>
<h4 id="konfigurera-openocd">Konfigurera OpenOCD</h4>
<p>Skapa filen <code>debug_openocd.cfg</code> och lägg till</p>
<pre><code># OpenOCD konfiguration. Specificerar att OpenOCD ska hitta en jlink interface till en nrf52 enhet
# och skicka data över den

source [find interface/jlink.cfg]

transport select swd

source [find target/nrf52.cfg]
</code></pre>
<h3 id="rust-runners">Rust runners</h3>
<p>En <em>runner</em> i rust syftar på det komandot som ska köras när en användare kör <code>cargo run</code>. I föregående 
exemplet så använde vi runnern som heter <code>probe-run</code>. Den är enkel att sätta upp, men låter oss inte 
debugga en enhet riktigt, utan endast printa från den.</p>
<p>Vi vill nu istället använda ett komando för att köra GDB med konfigfilen som vi just skapat. Redigera
<code>.cargo/config.toml</code> och ersätt raden</p>
<pre><code class="language-toml">runner = &quot;probe-run --chip nRF52840_xxAA&quot;
</code></pre>
<p>med</p>
<pre><code class="language-toml">runner = &quot;arm-none-eabi-gdb -q -x debug.gdb&quot;
</code></pre>
<h3 id="forsta-testet">Första testet</h3>
<p>Nu är alla bitar på plats för att börja testa att debugga. Vi gör första exemplet i en terminal, men
senare ska vi integrera allt med VSCode. Därför ser det lite omständigt ut nu.</p>
<p>Börja med att starta en terminal, gå till projektmappen <code>gdb_test</code> och kör</p>
<pre><code class="language-bash">openocd -f debug_openocd.cfg
</code></pre>
<p>Flaggan <code>-f</code> specificerar att OpenOCD ska använda filen <code>debug_openocd.cfg</code> som vi skapade tidigare.</p>
<p>Om allt gått som det ska, bör OpenOCD printa ut</p>
<pre><code>Open On-Chip Debugger 0.11.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : Listening on port 6666 for tcl connections
Info : Listening on port 4444 for telnet connections
Info : J-Link OB-nRF5340-NordicSemi compiled Nov  7 2022 16:22:01
Info : Hardware version: 1.00
Info : VTarget = 3.300 V
Info : clock speed 1000 kHz
Info : SWD DPIDR 0x2ba01477
Info : nrf52.cpu: hardware has 6 breakpoints, 4 watchpoints
Info : starting gdb server for nrf52.cpu on 3333
Info : Listening on port 3333 for gdb connections
</code></pre>
<p>Allt detta betyder att OpenOCD hittat en <code>OB-nRF5340-NordicSemi</code> enhet över ett <code>J-Link</code> interface.
Sedan startar den GDB servern och väntar på att en GDB instans ska koppla upp sig.</p>
<p>Öppna en annan terminal, gå till projektmappen <code>gdb_test</code> och kör</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Den kommer printa ut att den kör kommandot <code>arm-none-eabi-gdb -q -x debug.gdb target/thumbv7em-none-eabi/debug/gdb_test</code>, vilket är den runnern vi specificerat tidigare. En GDB instans startas och printar ut följande</p>
<pre><code class="language-gdb">Reading symbols from target/thumbv7em-none-eabi/debug/gdb_test...
cortex_m::asm::inline::__bkpt ()
    at /home/josef/.cargo/registry/src/github.com-1ecc6299db9ec823/cortex-m-0.7.6/src/../asm/inline.rs:14
14          asm!(&quot;bkpt&quot;, options(nomem, nostack, preserves_flags));
Loading section .vector_table, size 0x100 lma 0x0
Loading section .text, size 0x2030 lma 0x100
Loading section .rodata, size 0x680 lma 0x2130
Start address 0x00000100, load size 10160
Transfer rate: 15 KB/sec, 3386 bytes/write.
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00000100 msp: 0x20040000

Program received signal SIGTRAP, Trace/breakpoint trap.
gdb_test::exit () at src/main.rs:34
34              cortex_m::asm::bkpt();  
(gdb)
</code></pre>
<p>Det den säger i princip är att den kopplar ihop sig till OpenOCD instansen, resetar enheten som OpenOCD är
kopplad till och startar programmet. Sedan stoppar den när den kommer fram till rad 34 i funktionen <code>exit</code>. 
Går vi tillbaks till <a href="embedded-kod">hello world koden</a> som vi skrev tidigare och kollar på funktionen <code>exit</code>
kan vi faktiskt se där varför: Exit kallar på en assemblyinstruktion vid namn <code>bkpt</code> som står för <em>breakpoint</em>.
Det syftar på att en debugger som kommer till den instruktionen ska stanna programmet för att man ska kunna se 
på koden. Du har nu lyckats debugga din kod!</p>
<p>Om du går tillbaks till terminalen där du kör OpenOCD så ska den ha printat ut lite mer.</p>
<pre><code>Info : accepting 'gdb' connection on tcp/3333
Info : nRF52840-xxAA(build code: F0) 1024kB Flash, 256kB RAM
undefined debug reason 8 - target needs reset
Warn : Prefer GDB command &quot;target extended-remote 3333&quot; instead of &quot;target remote 3333&quot;
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00000100 msp: 0x20040000
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00000100 msp: 0x20040000
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00000100 msp: 0x20040000
</code></pre>
<p>Där står det att en GDB instans har kopplat till servern och skickat över ett program som ska till devboardet. 
OpenOCD programmerar devboardet och startar programmet, tills devboardet kommer till en breakpoint.</p>
<p>Längst ner i GDB terminalen ser du att det står <code>(gdb)</code> och att text som du skriver in i terminalen dyker upp där. 
Det syftar på att du är i en GDB konsol, där du kan integrera med körningen av programmet. 
Vi ska nu testa att lägga till en egen breakpoint och se om vi kan få enheten att stanna där. 
Kör följande komandon i GDB konsollen</p>
<p>Lägg till en breakpoint på rad 19 i programmet (på samma rad som rprintln)</p>
<pre><code class="language-gdb">break 19
</code></pre>
<p>Starta om enheten så att det kör från början av programmet igen</p>
<pre><code class="language-gdb">monitor reset init
</code></pre>
<p>Kör programmet</p>
<pre><code>continue
</code></pre>
<p>Nu bör konsollen visa att du hamnat på en breakpoint på rad 19</p>
<pre><code class="language-gdb">Breakpoint 1, gdb_test::__cortex_m_rt_main () at src/main.rs:19
19          rprintln!(&quot;Hello, World!&quot;);
</code></pre>
<p>Snyggt. Nu har du själv laggt en breakpoint i programmet.</p>
<p>Men frågan är då, hur ser vi vad som händer på enheten när den stannat? Det enklaste sättet är att använda GDBs
"grafiska" läge som heter <em>tui</em>. Detta får man igång igenom att skriva</p>
<pre><code>tui enable
</code></pre>
<p>Nu bör du få upp något som ser ut såhär
<img alt="" src="../../../Hardware/img/EmbeddedRust/GDB_TUI.png" /></p>
<p>Här är din kod. GDB markerar också vart någonstans som programmet har stannat. Du kan testa att be GDB köra en rad till och sedan stanna igen igenom att skriva</p>
<pre><code class="language-gdb">next
</code></pre>
<p>Nu bör GDB markera nästa rad i din mainfil. Testa nu att fortsätta köra programmet
tills nästa breakpoint</p>
<pre><code class="language-gdb">continue
</code></pre>
<p>Och du kommer tillbaks till exit funktionen. Vill du avsluda GDB kan du köra</p>
<pre><code class="language-gdb">exit
</code></pre>
<p>Den kommer att påpeka att programmet fortfarande körs, men låter dig avsluta om du 
trycker på <code>y</code>.</p>
<h3 id="anvandning-av-gdb">Användning av GDB</h3>
<p>Tyvärr är GDB i sig själv inte såpass intuitivt att det är enkelt att börja med. Man
kan sätta breakpoints och titta på variablers värden i GDB konsollen. Men anledningen
till att jag inte går djupare i det är för att vi senare ska koppla ihop GDB med
VSCode, för att kunna integrera med GDB därifrån. Det kommer att vara lite enklare,
men jag menar att det kan vara värt gå igenom hur hur GDB själv funkar för att få
en klarare bild över vad som sker i varje steg.</p>
<h2 id="embedded-rust-i-vscode">Embedded Rust i VSCode</h2>
<p>Nästa steg är att konfigurera VSCode så vi enkelt kan bygga vårt projekt och köra det.</p>
<p>Öppna VSCode och öppna projektet <code>gdb_test</code> (<code>File &gt; Open Folder</code>). Till att börja med kan du gå in i mappen <code>src</code> och öppna mainfilen. 
Den kommer att ge dig ett par errors, men de kan du ignorera just nu. Börja med att öppna en ny terminal (<code>Terminal &gt; New Terminal</code>) och kör</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>Det borde funka som tidigare. Den programerar ditt devboard och printar "Hello, World!". </p>
<p>Vi vill dock kunna programera enheten med "Run and Debug" knappen i VSCode. </p>
<p>Först behöver vi en <em>SVD</em> fil, som specificerar för OpenOCD hur den ska tolka specifika register på vår enhet. Som tur är har 
Nordic Semiconductors en SVD fil på Github. Klona deras <code>nrfx</code> repo i samma mapp som exempelna du gjort, och kopiera över filen 
<code>nrfx/mdk/nrf52840.svd</code> till mappen <code>gdb_test</code>.</p>
<pre><code class="language-bash">git clone git@github.com:NordicSemiconductor/nrfx.git
cp  nrfx/mdk/nrf52840.svd gdb_test
</code></pre>
<p>Sen behöver vi också ett plugin till VSCode som heter <em>Cortex-Debug</em>. Installera det på samma sätt som du installerade <a href="#rust-plugin">rust-analyzer</a>.
<a href="../../../Hardware/img/EmbeddedRust/VSCodeCortexDebug.png"></a></p>
<p><a href="https://www.electrorules.com/vscode-cortex-debug-launch-configurations/">ElectroRules - VSCode Cortex-Debug Launch Configurations</a></p>
<p>Nu ska du sätta upp din <code>launch.json</code> fil. Följ samma steg <a href="#kompilera-och-debugga-i-vs-code">vi gjorde tidigare</a> 
för att sätta upp Run and Debug. Det ger dig en <code>launch.json</code> fil. Vi vill dock ändra den så att istället för att koden körs lokalt, körs den
med GDB på embeddedenheten. Byt ut allt mellan måsvingarna från</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;lldb&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;name&quot;: &quot;Debug&quot;,
    &quot;program&quot;: &quot;${workspaceFolder}/&lt;executable file&gt;&quot;,
    &quot;args&quot;: [],
    &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
}
</code></pre>
<p>Till</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;Debug (OpenOCD)&quot;,
    &quot;type&quot;: &quot;cortex-debug&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
    &quot;executable&quot;: &quot;${workspaceFolder}/target/thumbv7em-none-eabi/debug/gdb_test&quot;,
    &quot;servertype&quot;: &quot;openocd&quot;,
    &quot;runToEntryPoint&quot;: &quot;main&quot;,
    &quot;configFiles&quot;: [&quot;debug_openocd.cfg&quot;],
    &quot;svdFile&quot;: &quot;${workspaceFolder}/nrf52840.svd&quot;
}
</code></pre>

			</div>
		</div>
	</body>
</html>